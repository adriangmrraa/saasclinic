/**
 * Component Testing & Optimization Script
 * Sprint 2 - Day 6: Testing & Optimization
 * 
 * This script analyzes components for optimization opportunities
 * and creates test templates.
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

console.log('ğŸ” COMPONENT TESTING & OPTIMIZATION');
console.log('='.repeat(60));

const baseDir = path.join(__dirname, 'src');
let recommendations = [];

function analyzeComponent(filePath, componentName) {
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    const lines = content.split('\n');
    
    console.log(`\nğŸ“Š Analyzing ${componentName}...`);
    console.log('-'.repeat(40));
    
    const stats = {
      lines: lines.length,
      imports: 0,
      exports: 0,
      functions: 0,
      hooks: 0,
      stateVariables: 0,
      effects: 0,
      apiCalls: 0,
      memoized: 0,
      errorBoundaries: 0,
      loadingStates: 0,
    };
    
    // Analyze content
    lines.forEach(line => {
      const trimmed = line.trim();
      
      if (trimmed.startsWith('import')) stats.imports++;
      if (trimmed.startsWith('export')) stats.exports++;
      if (trimmed.includes('function') || trimmed.includes('const') || trimmed.includes('let')) {
        if (trimmed.includes('=') && (trimmed.includes('useState') || trimmed.includes('useReducer'))) {
          stats.stateVariables++;
        }
        if (trimmed.includes('=>')) stats.functions++;
      }
      if (trimmed.includes('useEffect')) stats.effects++;
      if (trimmed.includes('useMemo') || trimmed.includes('useCallback')) stats.memoized++;
      if (trimmed.includes('use')) stats.hooks++;
      if (trimmed.includes('api.') || trimmed.includes('axios') || trimmed.includes('fetch')) stats.apiCalls++;
      if (trimmed.includes('ErrorBoundary') || trimmed.includes('try/catch')) stats.errorBoundaries++;
      if (trimmed.includes('loading') || trimmed.includes('isLoading') || trimmed.includes('Loading')) stats.loadingStates++;
    });
    
    // Print stats
    console.log(`ğŸ“ Lines of code: ${stats.lines}`);
    console.log(`ğŸ“¦ Imports: ${stats.imports}`);
    console.log(`ğŸ£ React hooks: ${stats.hooks}`);
    console.log(`âš¡ State variables: ${stats.stateVariables}`);
    console.log(`ğŸ”„ Effects: ${stats.effects}`);
    console.log(`ğŸ”— API calls: ${stats.apiCalls}`);
    console.log(`ğŸ’¾ Memoized values: ${stats.memoized}`);
    console.log(`ğŸ›¡ï¸ Error boundaries: ${stats.errorBoundaries}`);
    console.log(`â³ Loading states: ${stats.loadingStates}`);
    
    // Generate recommendations
    const compRecommendations = [];
    
    if (stats.lines > 300) {
      compRecommendations.push('Consider splitting into smaller components (over 300 lines)');
    }
    
    if (stats.apiCalls > 3) {
      compRecommendations.push(`Multiple API calls (${stats.apiCalls}) - consider batching or custom hook`);
    }
    
    if (stats.effects > 3) {
      compRecommendations.push(`Multiple useEffect hooks (${stats.effects}) - consider consolidation`);
    }
    
    if (stats.stateVariables > 5) {
      compRecommendations.push(`Many state variables (${stats.stateVariables}) - consider useReducer`);
    }
    
    if (stats.memoized < 2 && stats.functions > 5) {
      compRecommendations.push('Consider memoizing expensive functions with useMemo/useCallback');
    }
    
    if (stats.errorBoundaries === 0 && stats.apiCalls > 0) {
      compRecommendations.push('Add error handling for API calls');
    }
    
    if (stats.loadingStates === 0 && stats.apiCalls > 0) {
      compRecommendations.push('Add loading states for better UX');
    }
    
    if (compRecommendations.length > 0) {
      console.log('\nğŸ’¡ Optimization recommendations:');
      compRecommendations.forEach(rec => console.log(`  â€¢ ${rec}`));
      recommendations.push({ component: componentName, recommendations: compRecommendations });
    } else {
      console.log('\nâœ… Component is well-optimized!');
    }
    
    return stats;
    
  } catch (error) {
    console.log(`âŒ Error analyzing ${componentName}: ${error.message}`);
    return null;
  }
}

function generateTestTemplate(componentName, filePath) {
  const testTemplate = `/**
 * Test file for ${componentName}
 * Generated by optimization script
 */

import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { ${componentName} } from './${path.basename(filePath, '.tsx')}';

describe('${componentName}', () => {
  // Mock dependencies
  beforeEach(() => {
    // Setup mocks here
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('renders without crashing', () => {
    render(<${componentName} />);
    expect(screen.getByTestId('${componentName.toLowerCase()}-container')).toBeInTheDocument();
  });

  it('displays loading state when data is fetching', () => {
    render(<${componentName} isLoading={true} />);
    expect(screen.getByText(/loading/i)).toBeInTheDocument();
  });

  it('displays error state when API fails', () => {
    render(<${componentName} error="Failed to load data" />);
    expect(screen.getByText(/failed to load/i)).toBeInTheDocument();
  });

  it('calls API on mount', async () => {
    render(<${componentName} />);
    await waitFor(() => {
      // Verify API was called
    });
  });

  it('handles user interactions correctly', async () => {
    const user = userEvent.setup();
    render(<${componentName} />);
    
    // Test user interactions
    const button = screen.getByRole('button', { name: /submit/i });
    await user.click(button);
    
    // Verify interaction results
  });

  it('updates UI when props change', () => {
    const { rerender } = render(<${componentName} value="initial" />);
    expect(screen.getByText('initial')).toBeInTheDocument();
    
    rerender(<${componentName} value="updated" />);
    expect(screen.getByText('updated')).toBeInTheDocument();
  });

  // Add more specific tests based on component functionality
});

// Mock implementations
jest.mock('../api/marketing', () => ({
  marketingApi: {
    getStats: jest.fn().mockResolvedValue({ data: {} }),
    // Add other API mocks as needed
  }
}));

export {};`;

  const testDir = path.join(__dirname, '__tests__');
  if (!fs.existsSync(testDir)) {
    fs.mkdirSync(testDir, { recursive: true });
  }
  
  const testFilePath = path.join(testDir, `${componentName}.test.tsx`);
  fs.writeFileSync(testFilePath, testTemplate);
  console.log(`ğŸ“ Generated test template: ${testFilePath}`);
  
  return testFilePath;
}

function checkBundleSize() {
  console.log('\nğŸ“¦ BUNDLE SIZE ANALYSIS');
  console.log('-'.repeat(40));
  
  // Check for large dependencies
  const packageJson = JSON.parse(fs.readFileSync(path.join(__dirname, 'package.json'), 'utf8'));
  const dependencies = { ...packageJson.dependencies, ...packageJson.devDependencies };
  
  const largeDeps = [];
  Object.entries(dependencies).forEach(([dep, version]) => {
    // Common large dependencies to watch
    const largeDependencies = [
      'moment', 'lodash', 'axios', 'react-query', 'redux', 
      'chart.js', 'recharts', 'd3', 'ag-grid', 'fullcalendar'
    ];
    
    if (largeDependencies.some(largeDep => dep.includes(largeDep))) {
      largeDeps.push(dep);
    }
  });
  
  if (largeDeps.length > 0) {
    console.log('âš ï¸ Large dependencies detected:');
    largeDeps.forEach(dep => console.log(`  â€¢ ${dep}`));
    console.log('\nğŸ’¡ Consider:');
    console.log('  â€¢ Using tree-shakable alternatives (date-fns instead of moment)');
    console.log('  â€¢ Importing only needed functions (lodash-es)');
    console.log('  â€¢ Code splitting for large libraries');
  } else {
    console.log('âœ… No excessively large dependencies detected');
  }
}

function generatePerformanceRecommendations() {
  console.log('\nğŸš€ PERFORMANCE RECOMMENDATIONS');
  console.log('-'.repeat(40));
  
  const perfRecommendations = [
    'âœ… Code splitting: Consider React.lazy() for marketing routes',
    'âœ… Image optimization: Use next-gen formats (WebP) and lazy loading',
    'âœ… Bundle analysis: Run "npm run build -- --analyze" to identify large chunks',
    'âœ… Caching: Implement service workers for API responses',
    'âœ… Debouncing: Add debounce to search inputs and filters',
    'âœ… Virtualization: Implement for long lists (react-window)',
    'âœ… Prefetching: Prefetch marketing routes on hover',
    'âœ… Compression: Ensure gzip/brotli compression is enabled',
  ];
  
  perfRecommendations.forEach(rec => console.log(`  ${rec}`));
}

// ==================== MAIN ANALYSIS ====================

console.log('\nğŸ” ANALYZING MARKETING COMPONENTS');
console.log('='.repeat(60));

const componentsToAnalyze = [
  ['views/marketing/MarketingHubView.tsx', 'MarketingHubView'],
  ['views/marketing/MetaTemplatesView.tsx', 'MetaTemplatesView'],
  ['components/marketing/MarketingPerformanceCard.tsx', 'MarketingPerformanceCard'],
  ['components/marketing/MetaConnectionWizard.tsx', 'MetaConnectionWizard'],
  ['components/marketing/MetaTokenBanner.tsx', 'MetaTokenBanner'],
];

const allStats = [];

componentsToAnalyze.forEach(([file, name]) => {
  const filePath = path.join(baseDir, file);
  if (fs.existsSync(filePath)) {
    const stats = analyzeComponent(filePath, name);
    if (stats) allStats.push({ name, stats });
    
    // Generate test template
    generateTestTemplate(name, filePath);
  }
});

// Bundle size analysis
checkBundleSize();

// Performance recommendations
generatePerformanceRecommendations();

// Summary
console.log('\n' + '='.repeat(60));
console.log('ğŸ“Š ANALYSIS SUMMARY');
console.log('='.repeat(60));

if (allStats.length > 0) {
  const totalLines = allStats.reduce((sum, { stats }) => sum + stats.lines, 0);
  const totalApiCalls = allStats.reduce((sum, { stats }) => sum + stats.apiCalls, 0);
  const totalStateVars = allStats.reduce((sum, { stats }) => sum + stats.stateVariables, 0);
  
  console.log(`\nğŸ“ˆ Total components analyzed: ${allStats.length}`);
  console.log(`ğŸ“ Total lines of code: ${totalLines}`);
  console.log(`ğŸ”— Total API calls: ${totalApiCalls}`);
  console.log(`âš¡ Total state variables: ${totalStateVars}`);
  
  if (recommendations.length > 0) {
    console.log('\nğŸ’¡ RECOMMENDATIONS SUMMARY:');
    recommendations.forEach(({ component, recommendations: recs }) => {
      console.log(`\n${component}:`);
      recs.forEach(rec => console.log(`  â€¢ ${rec}`));
    });
  } else {
    console.log('\nğŸ‰ All components are well-optimized!');
  }
}

console.log('\nğŸ”§ NEXT STEPS FOR OPTIMIZATION:');
console.log('1. Run generated tests: npm test');
console.log('2. Analyze bundle: npm run build -- --analyze');
console.log('3. Implement code splitting for marketing routes');
console.log('4. Add error boundaries around API calls');
console.log('5. Implement loading skeletons for better UX');
console.log('6. Add performance monitoring with React Profiler');

console.log('\nâœ… Sprint 2 Day 6 (Testing & Optimization) complete!');
console.log('ğŸ“ Test templates generated in __tests__/ directory');
console.log('ğŸ’¡ Optimization recommendations provided above');